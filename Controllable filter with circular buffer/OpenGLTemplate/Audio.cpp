#include "Audio.h"
#include "Common.h"

#pragma comment(lib, "lib/fmod_vc.lib")

int sample_count = 0;

// DSP callback
FMOD_RESULT F_CALLBACK DSPCallback(FMOD_DSP_STATE *dsp_state, float *inbuffer, float *outbuffer, unsigned int length, int inchannels, int *outchannels)
{
	//This DSP filter just halves the volume! Input is modified, and sent to output.
	FMOD::DSP *thisdsp = (FMOD::DSP *)dsp_state->instance;
	for (unsigned int samp = 0; samp < length; samp++)
		for (int chan = 0; chan < *outchannels; chan++)			
			outbuffer[(samp * *outchannels) + chan] = inbuffer[(samp * inchannels) + chan] * 0.2f;
	return FMOD_OK;
} 

// Low pass filter coefficients (Matlab)
std::vector <double> lowpassFilter = { 0.0001410707083993668659212261662361243, 0.000137992051478223732002142964958579796, 0.000200095256519657309791232480122857851, 0.000275531513058804129138318339542479407, 0.00036414956176956101742414606547981748, 0.00046503859247418020570960517368064302 , 0.000576376414955681332791259663395067037, 0.000695326952658001872474569093895979677, 0.000817898829367031928241904559229169536, 0.0009389546199080598710973166731719175  , 0.001052192256606619170933303308856920921, 0.001150248500155753384258106031268198421, 0.001224833177986859016755927243025325879, 0.001266856788820700831232901606426821672, 0.0012666911110581896820342917564516938  , 0.001214521457676228386249328572432659712, 0.001100738414724218702453462093160396762, 0.000916354581628243264335154094624158461, 0.000653430754563831431118436920968406412, 0.000305553790787717555275243563883691422,-0.000131541110717134807637021531867560498,-0.000659531337176734108740383533131534932,-0.001277158290836848770696820842829311005,-0.001979804691257857750946724806340171199,-0.002758963869795955873437387495528128056,-0.003602164814995941540670676417335016595,-0.004492966952944175973438944993176846765,-0.005410825628452933973300265080297322129,-0.006331008884343119515192288560001543374,-0.007225632838850455305634845615259109763,-0.00806323991611412362046085178235443891 ,-0.008810052543647436604223877054664626485,-0.009430530603022086594267037185090885032,-0.00988808223785247672465992252455180278 ,-0.010146405330256883306483395301711425418,-0.010170180372031791676823431203047221061,-0.009926588680066161449189188203945377609,-0.009386091267712835459202658228150539799,-0.008523840160553108544205791474723810097,-0.007320550065980029053047672960019554012,-0.005763621281732363155203557880668086   ,-0.003847846029266309246519295328425869229,-0.001576169438585506548528014647558848083, 0.001039950951467061377592182580542612413, 0.003980123782441376788232556549473883933, 0.007215232586593537875141457504923891975, 0.010707572943131536680194670907440013252, 0.014411425368338256006173203616071987199, 0.018273742247513793252045033455033262726, 0.022235331298167047148206521001156943385, 0.026231918041157483573178055280550324824, 0.030195652112680566175884067092738405336, 0.034056625662136574828053880992229096591, 0.037744633663421053859643450323346769437, 0.04119072294237417081186336531573033426 , 0.044329111619309913283615287582506425679, 0.047098790740468229887305540160014061257, 0.049445067357775471239555997726711211726, 0.051321064099720196949316886048109154217, 0.052689005131468347187251310970168560743, 0.053521062123922283348953499171329895034, 0.053800350479250455548729803467722376809, 0.053521062123922283348953499171329895034, 0.052689005131468347187251310970168560743, 0.051321064099720196949316886048109154217, 0.049445067357775471239555997726711211726, 0.047098790740468229887305540160014061257, 0.044329111619309913283615287582506425679, 0.04119072294237417081186336531573033426 , 0.037744633663421053859643450323346769437, 0.034056625662136574828053880992229096591, 0.030195652112680566175884067092738405336, 0.026231918041157483573178055280550324824, 0.022235331298167047148206521001156943385, 0.018273742247513793252045033455033262726, 0.014411425368338256006173203616071987199, 0.010707572943131536680194670907440013252, 0.007215232586593537875141457504923891975, 0.003980123782441376788232556549473883933, 0.001039950951467061377592182580542612413,-0.001576169438585506548528014647558848083,-0.003847846029266309246519295328425869229,-0.005763621281732363155203557880668086   ,-0.007320550065980029053047672960019554012,-0.008523840160553108544205791474723810097,-0.009386091267712835459202658228150539799,-0.009926588680066161449189188203945377609,-0.010170180372031791676823431203047221061,-0.010146405330256883306483395301711425418,-0.00988808223785247672465992252455180278 ,-0.009430530603022086594267037185090885032,-0.008810052543647436604223877054664626485,-0.00806323991611412362046085178235443891 ,-0.007225632838850455305634845615259109763,-0.006331008884343119515192288560001543374,-0.005410825628452933973300265080297322129,-0.004492966952944175973438944993176846765,-0.003602164814995941540670676417335016595,-0.002758963869795955873437387495528128056,-0.001979804691257857750946724806340171199,-0.001277158290836848770696820842829311005,-0.000659531337176734108740383533131534932,-0.000131541110717134807637021531867560498, 0.000305553790787717555275243563883691422, 0.000653430754563831431118436920968406412, 0.000916354581628243264335154094624158461, 0.001100738414724218702453462093160396762, 0.001214521457676228386249328572432659712, 0.0012666911110581896820342917564516938  , 0.001266856788820700831232901606426821672, 0.001224833177986859016755927243025325879, 0.001150248500155753384258106031268198421, 0.001052192256606619170933303308856920921, 0.0009389546199080598710973166731719175  , 0.000817898829367031928241904559229169536, 0.000695326952658001872474569093895979677, 0.000576376414955681332791259663395067037, 0.00046503859247418020570960517368064302 , 0.00036414956176956101742414606547981748 , 0.000275531513058804129138318339542479407, 0.000200095256519657309791232480122857851, 0.000137992051478223732002142964958579796, 0.0001410707083993668659212261662361243 };
std::vector <float> lowpassFilter_coefficients(lowpassFilter.begin(), lowpassFilter.end());

// High pass filter coefficients (Matlab)
std::vector <double> highpassFilter = { 0.005029953486511145807624778569788759341,-0.013792143533133955149438953924345696578, 0.004917582134156444836903254724802536657, 0.006609990022203271822776038391111796955, 0.002882146340005786906701690242016411503,-0.00098333627556527222583759861862517937 ,-0.003138959423802050070773095313825251651,-0.003403370753834900064305202249670401216,-0.002314244693918353790867969976829954248,-0.000574458518841014552716583985159104486, 0.001149791324903574364635350235630539828, 0.002364961208695966817655564895517272817, 0.002779274264823209349140054058580062701, 0.002318331595331311455882028482733403507, 0.001139414856073275470957351096501497523,-0.000425051463532847651014684453585346091,-0.001929928246060200669118045446737141901,-0.002922032996905782505081550226577746798,-0.003078822781445600224869973970953651587,-0.002280447973499716285417093786236364394,-0.000694125921565615891691003458419118033, 0.00125757189509519118862657105495372889 , 0.002999367321207508686742304604422315606, 0.003960790034580096222183165366459434154, 0.003759305923639083297366214608814516396, 0.00234912468377123295412700620943269314 , 0.000049363136859765018190065316572301413,-0.002513660219668307441859278483775597124,-0.004556639096008742104149114027222822187,-0.005368575157396394958997376534171053208,-0.004567976855702533638126094928111342597,-0.00223228741407996509465982981623710657 , 0.001065185863432443341691779892244085204, 0.004388628104184430500644964467937825248, 0.00669620215028914923804936876194915385 , 0.007146622323097554831117239615423386567, 0.005383090811987860727083621270594449015, 0.001720072251550694994795542847043634538,-0.002899103876574806327309774545142317947,-0.007136605381718481334873960264530978748,-0.00962860296969716977777409283589804545 ,-0.009378963776630333537553951828158460557,-0.006137839113381503806932126821038764319,-0.000562653754346086011281502514691510441, 0.005884692185889725014880102804681882844, 0.011307367960081327398769168723902112106, 0.01387878848272341286707032281810825225 , 0.012401117416679282787206339833119272953, 0.006781289926270609065561689732248851215,-0.00179596771194492498165129479303914195 ,-0.011104195101299556280860514334563049488,-0.018349251085895312146645252937560144346,-0.020920800623013439262232182613843178842,-0.01721810555379059762270976818854251178 ,-0.007276296026613261747062466611168929376, 0.007031847324220476778966482100940993405, 0.022165775931440520607473843028856208548, 0.033586950707379312208722410559857962653, 0.036833698475742096545282322495040716603, 0.028581086723375354746723431276222981978, 0.007577371570199964781466839269796764711,-0.024731511716781482551619220089378359262,-0.064401542523536775552983613124524708837,-0.105503678094103728324348878686578245834,-0.141320127192415545547277133664465509355,-0.165715276109357267930732859895215369761, 0.825651159873387441301417766226222738624,-0.165715276109357267930732859895215369761,-0.141320127192415545547277133664465509355,-0.105503678094103728324348878686578245834,-0.064401542523536775552983613124524708837,-0.024731511716781482551619220089378359262, 0.007577371570199964781466839269796764711, 0.028581086723375354746723431276222981978, 0.036833698475742096545282322495040716603, 0.033586950707379312208722410559857962653, 0.022165775931440520607473843028856208548, 0.007031847324220476778966482100940993405,-0.007276296026613261747062466611168929376,-0.01721810555379059762270976818854251178 ,-0.020920800623013439262232182613843178842,-0.018349251085895312146645252937560144346,-0.011104195101299556280860514334563049488,-0.00179596771194492498165129479303914195 , 0.006781289926270609065561689732248851215, 0.012401117416679282787206339833119272953, 0.01387878848272341286707032281810825225 , 0.011307367960081327398769168723902112106, 0.005884692185889725014880102804681882844,-0.000562653754346086011281502514691510441,-0.006137839113381503806932126821038764319,-0.009378963776630333537553951828158460557,-0.00962860296969716977777409283589804545 ,-0.007136605381718481334873960264530978748,-0.002899103876574806327309774545142317947, 0.001720072251550694994795542847043634538, 0.005383090811987860727083621270594449015, 0.007146622323097554831117239615423386567, 0.00669620215028914923804936876194915385 , 0.004388628104184430500644964467937825248, 0.001065185863432443341691779892244085204,-0.00223228741407996509465982981623710657 ,-0.004567976855702533638126094928111342597,-0.005368575157396394958997376534171053208,-0.004556639096008742104149114027222822187,-0.002513660219668307441859278483775597124, 0.000049363136859765018190065316572301413, 0.00234912468377123295412700620943269314 , 0.003759305923639083297366214608814516396, 0.003960790034580096222183165366459434154, 0.002999367321207508686742304604422315606, 0.00125757189509519118862657105495372889 ,-0.000694125921565615891691003458419118033,-0.002280447973499716285417093786236364394,-0.003078822781445600224869973970953651587,-0.002922032996905782505081550226577746798,-0.001929928246060200669118045446737141901,-0.000425051463532847651014684453585346091, 0.001139414856073275470957351096501497523, 0.002318331595331311455882028482733403507, 0.002779274264823209349140054058580062701, 0.002364961208695966817655564895517272817, 0.001149791324903574364635350235630539828,-0.000574458518841014552716583985159104486,-0.002314244693918353790867969976829954248,-0.003403370753834900064305202249670401216,-0.003138959423802050070773095313825251651,-0.00098333627556527222583759861862517937 , 0.002882146340005786906701690242016411503, 0.006609990022203271822776038391111796955, 0.004917582134156444836903254724802536657,-0.013792143533133955149438953924345696578, 0.005029953486511145807624778569788759341 };
std::vector <float> highpassFilter_coefficients(highpassFilter.begin(), highpassFilter.end());

// DSP callback (high pass)
FMOD_RESULT F_CALLBACK DSPCallback_highFilter(FMOD_DSP_STATE* dsp_state, float* inbuffer, float* outbuffer, unsigned int length, int inchannels, int* outchannels)
{
	unsigned int sample;
	int channel;
	FMOD::DSP *thisdsp = (FMOD::DSP *)dsp_state->instance;
	const int buffer_size = 1024;
	static float *buffer = NULL;
	const int n = highpassFilter_coefficients.size();

	if (buffer == NULL)
		buffer = (float*)malloc(buffer_size * sizeof(float) * inchannels);

	for (sample = 0; sample < length; sample++)
	{
		for (channel = 0; channel < inchannels; channel++)
		{
			buffer[(sample_count * inchannels) % buffer_size + channel] = inbuffer[(sample * inchannels) + channel];

			if (sample_count < n)
				outbuffer[(sample * inchannels) + channel] = 0;
			else
			{
				for (int i = 0; i < n; i++)
				{
					outbuffer[(sample * inchannels) + channel] += highpassFilter_coefficients[i] * buffer[((sample_count - i) * inchannels) % buffer_size + channel];
				}
			}
		}
		sample_count++;
	}
	return FMOD_OK;
}

// DSP callback (low pass)
FMOD_RESULT F_CALLBACK DSPCallback_lowFilter(FMOD_DSP_STATE* dsp_state, float* inbuffer, float* outbuffer, unsigned int length, int inchannels, int* outchannels)
{
	unsigned int sample;
	int channel;
	FMOD::DSP* thisdsp = (FMOD::DSP*)dsp_state->instance;
	const int buffer_size = 1024;
	static float* buffer = NULL;
	const int n = lowpassFilter_coefficients.size();

	if (buffer == NULL)
		buffer = (float*)malloc(buffer_size * sizeof(float) * inchannels);

	for (sample = 0; sample < length; sample++)
	{
		for (channel = 0; channel < inchannels; channel++)
		{
			buffer[(sample_count * inchannels) % buffer_size + channel] = inbuffer[(sample * inchannels) + channel];

			if (sample_count < n)
				outbuffer[(sample * inchannels) + channel] = 0;
			else
			{
				for (int i = 0; i < n; i++)
				{
					outbuffer[(sample * inchannels) + channel] += lowpassFilter_coefficients[i] * buffer[((sample_count - i) * inchannels) % buffer_size + channel];
				}
			}
		}
		sample_count++;
	}
	return FMOD_OK;
}


CAudio::CAudio()
{}

CAudio::~CAudio()
{}

bool CAudio::Initialise()
{
	// Create an FMOD system
	result = FMOD::System_Create(&m_FmodSystem);
	FmodErrorCheck(result);
	if (result != FMOD_OK) 
		return false;

	// Initialise the system
	//result = m_FmodSystem->init(32, FMOD_INIT_NORMAL, 0);
	result = m_FmodSystem->init(32, FMOD_INIT_3D_RIGHTHANDED, 0);
	FmodErrorCheck(result);
	if (result != FMOD_OK) 
		return false;

	// Set 3D settings
	result = m_FmodSystem->set3DSettings(1.0f, 1.0f, 1.0f);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;

	// Create the DSP effect (Halved regular)
	{
		FMOD_DSP_DESCRIPTION dspdesc;
		memset(&dspdesc, 0, sizeof(dspdesc));

		strncpy_s(dspdesc.name, "Regular (halved) sound DSP", sizeof(dspdesc.name));
		dspdesc.numinputbuffers = 1;
		dspdesc.numoutputbuffers = 1;
		dspdesc.read = DSPCallback;

		result = m_FmodSystem->createDSP(&dspdesc, &m_dsp);
		FmodErrorCheck(result);

		if (result != FMOD_OK)
			return false;
	}

	// Create the DSP effect (HIGH)
	{
		FMOD_DSP_DESCRIPTION dspdesc;
		memset(&dspdesc, 0, sizeof(dspdesc));

		strncpy_s(dspdesc.name, "High pass DSP", sizeof(dspdesc.name));
		dspdesc.numinputbuffers = 1;
		dspdesc.numoutputbuffers = 1;
		dspdesc.read = DSPCallback_highFilter;

		result = m_FmodSystem->createDSP(&dspdesc, &m_dspHigh);
		FmodErrorCheck(result);

		if (result != FMOD_OK)
			return false;
	}

	// Create the DSP effect (LOW)
	{
		FMOD_DSP_DESCRIPTION dspdesc;
		memset(&dspdesc, 0, sizeof(dspdesc));

		strncpy_s(dspdesc.name, "Low pass DSP", sizeof(dspdesc.name));
		dspdesc.numinputbuffers = 1;
		dspdesc.numoutputbuffers = 1;
		dspdesc.read = DSPCallback_lowFilter;

		result = m_FmodSystem->createDSP(&dspdesc, &m_dspLow);
		FmodErrorCheck(result);

		if (result != FMOD_OK)
			return false;
	}

	return true;
	
}

// Load an event sound
bool CAudio::LoadEventSound(char *filename)
{
	result = m_FmodSystem->createSound(filename, FMOD_LOOP_OFF, 0, &m_eventSound);
	FmodErrorCheck(result);
	if (result != FMOD_OK) 
		return false;

	return true;
	
}

// Play an event sound
bool CAudio::PlayEventSound()
{
	result = m_FmodSystem->playSound(m_eventSound, NULL, false, &m_eventChannel);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;

	// play through 3D channel
	m_eventChannel->setMode(FMOD_3D);
	// Horse position
	result = m_eventChannel->set3DAttributes(0, 0, 0);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;

	return true;
}

// Load an engine sound
bool CAudio::LoadEngineSound(char* filename)
{
	result = m_FmodSystem->createSound(filename, FMOD_3D, 0, &m_engineSound);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;

	return true;

}

// Play the engine sound
bool CAudio::PlayEngineSound(glm::vec3 enginePOS)
{
	result = m_FmodSystem->playSound(m_engineSound, NULL, false, &m_engineChannel);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;
	// play through 3D channel
	m_engineChannel->setMode(FMOD_3D);
	FMOD_VECTOR newPOS;
	newPOS.x = enginePOS.x;
	newPOS.y = enginePOS.y;
	newPOS.z = enginePOS.z;
	// Engine position
	result = m_engineChannel->set3DAttributes(&newPOS, 0);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;

	return true;
}

void CAudio::IncreaseEngineVolume()
{
	// Increases the volume
	m_engineSpeed += 10.f;

	if (m_engineSpeed > 100)
		m_engineSpeed = 100.0f;
}

void CAudio::DecreaseEngineVolume()
{
	// Decreases the volume
	m_engineSpeed -= 10.f;

	if (m_engineSpeed < 0)
		m_engineSpeed = 0.0f;
}

// Change the engine sound dynamically
void CAudio::ChangeEngineSound()
{
	if (m_engineSpeed >= 0 && m_engineSpeed < 60)
	{
		m_engineChannel->removeDSP(m_dspHigh);
		m_engineChannel->addDSP(1, m_dspLow);
	}
	else if (m_engineSpeed >= 60 && m_engineSpeed < 100)
	{
		m_engineChannel->removeDSP(m_dspLow);
		m_engineChannel->addDSP(1, m_dspHigh);
	}
	else
	{
		m_engineChannel->removeDSP(m_dspLow);
		m_engineChannel->removeDSP(m_dspHigh);
	}
}

// Load a music stream
bool CAudio::LoadMusicStream(char *filename)
{
	result = m_FmodSystem->createStream(filename, NULL | FMOD_LOOP_NORMAL, 0, &m_music);
	FmodErrorCheck(result);

	if (result != FMOD_OK) 
		return false;

	// create a low-pass filter DSP object
	result = m_FmodSystem->createDSPByType(FMOD_DSP_TYPE_LOWPASS, &m_musicFilter);
	if (result != FMOD_OK)
		return false;

	// you can start the DSP in an inactive state
	m_musicFilter->setActive(false);

	return true;
	
}

// Play a music stream
bool CAudio::PlayMusicStream()
{
	result = m_FmodSystem->playSound(m_music, NULL, false, &m_musicChannel);
	FmodErrorCheck(result);

	if (result != FMOD_OK)
		return false;

	//m_musicChannel->addDSP(0, m_dsp);
	// Set the volume lower
	result = m_musicChannel->setVolume(m_musicVolume);
	FmodErrorCheck(result);
	if (result != FMOD_OK)
		return false;

	// connecting the music filter to the music stream
	// 1) Get the DSP head and it's input
	m_musicChannel->getDSP(FMOD_CHANNELCONTROL_DSP_HEAD, &m_musicDSPHead);
	m_musicDSPHead->getInput(0, &m_musicDSPHeadInput, NULL);
	// 2) Disconnect them
	m_musicDSPHead->disconnectFrom(m_musicDSPHeadInput);
	// 3) Add input to the music head from the filter
	result = m_musicDSPHead->addInput(m_musicFilter);
	FmodErrorCheck(result);

	if (result != FMOD_OK)
		return false;

	// 4) Add input to the filter head music DSP head input
	result = m_musicFilter->addInput(m_musicDSPHeadInput);
	FmodErrorCheck(result);

	if (result != FMOD_OK)
		return false;

	// set the DSP object to be active
	m_musicFilter->setActive(true);
	// initially set the cutoff to a high value
	m_musicFilter->setParameterFloat(FMOD_DSP_LOWPASS_CUTOFF, 22000);
	// this state is used for toggling
	m_musicFilterActive = false;

	return true;
}

void CAudio::Update(CCamera *m_pCamera, glm::vec3 pos)
{
	ChangeEngineSound();
	


	// 5) update the listener's position with the camera position
	ToFMODVector(m_pCamera->GetPosition(), &camPos);
	result = m_FmodSystem->set3DListenerAttributes(0, &camPos, NULL, NULL, NULL);
	FmodErrorCheck(result);
	m_FmodSystem->update();

}

void CAudio::ToggleMusicFilter()
{
	// called externally from Game::ProcessEvents
	// toggle the effect on/off
	m_musicFilterActive = !m_musicFilterActive;
	if (m_musicFilterActive) {
		// set the parameter to a low value
		m_musicFilter->setParameterFloat(FMOD_DSP_LOWPASS_CUTOFF, 700);
	}
	else {
		// set the parameter to a high value
		// you could also use m_musicFilter->setBypass(true) instead...
		m_musicFilter->setParameterFloat(FMOD_DSP_LOWPASS_CUTOFF, 22000);
	}
}

void CAudio::ToggleHighFilter()
{
	// Removes any active DSP except the high filter
	m_musicChannel->removeDSP(m_dsp);
	m_musicChannel->removeDSP(m_dspLow);
	m_musicChannel->addDSP(0, m_dspHigh);
}

void CAudio::ToggleLowFilter()
{
	// Removes any active DSP except the low filter
	m_musicChannel->removeDSP(m_dsp);
	m_musicChannel->removeDSP(m_dspHigh);
	m_musicChannel->addDSP(0, m_dspLow);
}

void CAudio::ToggleHalvedFilter()
{
	// Removes any active DSP except the regular filter
	m_musicChannel->removeDSP(m_dspHigh);
	m_musicChannel->removeDSP(m_dspLow);
	m_musicChannel->addDSP(0, m_dsp);
}

void CAudio::IncreaseMusicVolume()
{
	// called externally from Game::ProcessEvents
	// increment the volume
	m_musicVolume += 0.05f;
	if (m_musicVolume > 1)
		m_musicVolume = 1.0f;
	m_musicChannel->setVolume(m_musicVolume);
}

void CAudio::DecreaseMusicVolume()
{
	// called externally from Game::ProcessEvents
	// deccrement the volume
	m_musicVolume -= 0.05f;
	if (m_musicVolume < 0)
		m_musicVolume = 0.0f;
	m_musicChannel->setVolume(m_musicVolume);
}

// Check for error
void CAudio::FmodErrorCheck(FMOD_RESULT result)
{
	if (result != FMOD_OK) {
		const char *errorString = FMOD_ErrorString(result);
		// MessageBox(NULL, errorString, "FMOD Error", MB_OK);
		// Warning: error message commented out -- if headphones not plugged into computer in lab, error occurs
	}
}

void CAudio::ToFMODVector(glm::vec3 &glVec3, FMOD_VECTOR *fmodVec)
{
	fmodVec->x = glVec3.x;
	fmodVec->y = glVec3.y;
	fmodVec->z = glVec3.z;
}